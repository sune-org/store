[
  {
    "id": "csx7463",
    "name": "Github Sync",
    "pinned": false,
    "avatar": "",
    "url": "gh://sune-org/store@main/sync.sune",
    "updatedAt": 1756949690375,
    "settings": {
      "model": "openai/gpt-5",
      "temperature": 1,
      "top_p": 0.97,
      "top_k": 0,
      "frequency_penalty": 0,
      "presence_penalty": 0,
      "repetition_penalty": 1,
      "min_p": 0,
      "top_a": 0,
      "max_tokens": 0,
      "verbosity": "",
      "reasoning_effort": "default",
      "system_prompt": "",
      "html": "<div id=\"githubSyncSune\" class=\"p-4 mx-4 mb-4 bg-gray-50/50 border rounded-lg\">\n    <!-- Sune version v1.5.0 -->\n    <div class=\"space-y-3\">\n        <div>\n            <p id=\"infoText\" class=\"p-3 text-sm text-center text-gray-600 border border-dashed rounded-md break-all\"></p>\n        </div>\n        <div>\n            <button id=\"syncBtn\" class=\"inline-flex items-center justify-center w-full px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent rounded-lg shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors\">\n                <!-- Content dynamically set by script -->\n            </button>\n        </div>\n        <div>\n            <label for=\"logArea\" class=\"block mb-1 text-xs font-medium text-gray-500\">Sync Logs</label>\n            <pre id=\"logArea\" class=\"w-full h-32 p-2.5 overflow-auto font-mono text-xs text-gray-600 bg-white border border-gray-200 rounded-md whitespace-pre-wrap\"></pre>\n        </div>\n    </div>\n</div>\n\n<script>\n(() => {\n    // --- Configuration ---\n    const hideUI = true // Set to true to hide the sync UI panel below the sync icon.\n    // -------------------\n\n    const suneContainer = document.getElementById('githubSyncSune');\n    if (!suneContainer || suneContainer.dataset.initialized) return;\n    suneContainer.dataset.initialized = 'true';\n\n    const infoText = suneContainer.querySelector('#infoText');\n    const syncBtn = suneContainer.querySelector('#syncBtn');\n    const logArea = suneContainer.querySelector('#logArea');\n    const mainSyncButton = document.getElementById('syncSune');\n\n    if (!window.SUNE || !window.USER) {\n        if (logArea) logArea.textContent = 'ERROR: Core Sune environment not found.';\n        return;\n    }\n\n    const activeSune = window.SUNE.active;\n    if (!activeSune) {\n        if (logArea) logArea.textContent = 'Error: No active sune found.';\n        return;\n    }\n\n    let worker = null;\n    let syncTimeout = null;\n    let syncPopover = null;\n    let longPressTimer = null;\n    let bodyClickListener = null;\n\n    const state = {\n        isBusy: false,\n        remoteSha: null,\n        pathInfo: null,\n        syncAction: 'none',\n        forceSync: false,\n    };\n\n    const log = (message) => {\n        if (!logArea || hideUI) return;\n        const timestamp = new Date().toLocaleTimeString();\n        logArea.textContent += `[${timestamp}] ${message}\\n`;\n        logArea.scrollTop = logArea.scrollHeight;\n    };\n    \n    const updateMainSyncBadge = (text) => {\n        const badge = document.getElementById('suneSyncBadge');\n        if (!badge) return;\n\n        if (text) {\n            badge.textContent = text;\n            badge.classList.remove('hidden');\n        } else {\n            badge.classList.add('hidden');\n        }\n    };\n\n    const clearSyncTimeout = () => {\n        if (syncTimeout) {\n            clearTimeout(syncTimeout);\n            syncTimeout = null;\n        }\n    };\n\n    const setBusy = (busy) => {\n        state.isBusy = busy;\n        const icon = mainSyncButton?.querySelector('svg');\n        if (icon) {\n            if (busy) {\n                icon.classList.add('animate-spin');\n            } else {\n                icon.classList.remove('animate-spin');\n            }\n        }\n        if (!busy) {\n            clearSyncTimeout();\n            updateMainSyncBadge(null); // Clear badge on any finish.\n        }\n    };\n    \n    // --- Popover Functions ---\n    const createSyncPopover = () => {\n        if (document.getElementById('suneSyncActionPopover')) return;\n\n        const popover = document.createElement('div');\n        popover.id = 'suneSyncActionPopover';\n        popover.className = 'menu-card hidden'; // Uses main app's CSS\n\n        const button = document.createElement('button');\n        button.className = 'menu-item';\n        button.innerHTML = `<i data-lucide=\"download-cloud\" class=\"h-4 w-4\"></i><span>Overwrite local with Remote</span>`;\n\n        button.addEventListener('click', (e) => {\n            e.stopPropagation();\n            hideSyncPopover();\n            performForceDownload();\n        });\n\n        popover.appendChild(button);\n        document.body.appendChild(popover);\n        syncPopover = popover;\n        if (window.lucide) window.lucide.createIcons({ nodes: [popover] });\n    };\n\n    const showSyncPopover = (btn) => {\n        if (!syncPopover || state.isBusy) return;\n        const r = btn.getBoundingClientRect();\n        syncPopover.style.top = (r.bottom + 4) + 'px';\n        const popoverWidth = 240; \n        syncPopover.style.left = Math.min(window.innerWidth - popoverWidth, Math.max(8, r.left - popoverWidth/2)) + 'px';\n        syncPopover.classList.remove('hidden');\n    };\n\n    const hideSyncPopover = () => {\n        syncPopover?.classList.add('hidden');\n    };\n    // --- End Popover Functions ---\n\n    const updateSyncButtonUI = (action, sha) => {\n        state.syncAction = action;\n        if (action !== 'synced') {\n            state.remoteSha = sha;\n        }\n        if (hideUI) return;\n        \n        switch (action) {\n            case 'upload':\n                syncBtn.disabled = state.isBusy;\n                syncBtn.innerHTML = `<i data-lucide=\"upload-cloud\" class=\"w-5 h-5 mr-2\"></i><span>${sha ? 'Upload Changes' : 'Create on GitHub'}</span>`;\n                break;\n            case 'synced':\n                syncBtn.disabled = true;\n                syncBtn.innerHTML = `<i data-lucide=\"check-circle-2\" class=\"w-5 h-5 mr-2\"></i><span>In Sync</span>`;\n                break;\n            default:\n                syncBtn.disabled = true;\n                syncBtn.innerHTML = `<i data-lucide=\"help-circle\" class=\"w-5 h-5 mr-2\"></i><span>Configure Sync Path</span>`;\n                break;\n        }\n        if (window.lucide) window.lucide.createIcons();\n    };\n\n    const cleanup = () => {\n        clearSyncTimeout();\n        if (worker) {\n            worker.terminate();\n            worker = null;\n        }\n        if (mainSyncButton && mainSyncButton.__syncClickListener) {\n            mainSyncButton.removeEventListener('click', mainSyncButton.__syncClickListener);\n            delete mainSyncButton.__syncClickListener;\n        }\n        if (mainSyncButton && mainSyncButton.__syncTouchListeners) {\n            mainSyncButton.removeEventListener('touchstart', mainSyncButton.__syncTouchListeners.start);\n            mainSyncButton.removeEventListener('touchend', mainSyncButton.__syncTouchListeners.cancel);\n            mainSyncButton.removeEventListener('touchmove', mainSyncButton.__syncTouchListeners.cancel);\n            mainSyncButton.removeEventListener('contextmenu', mainSyncButton.__syncTouchListeners.context);\n            delete mainSyncButton.__syncTouchListeners;\n        }\n        if (syncPopover) {\n            syncPopover.remove();\n            syncPopover = null;\n        }\n        if (bodyClickListener) {\n            document.body.removeEventListener('click', bodyClickListener, true);\n            bodyClickListener = null;\n        }\n        suneContainer.dataset.initialized = '';\n    };\n\n    const createWorker = () => {\n        const workerCode = `\n            const GITHUB_API = 'https://api.github.com';\n            async function apiCall(method, path, token, body = null) {\n                const headers = { 'Authorization': \\`token \\${token}\\`, 'Accept': 'application/vnd.github.v3+json' };\n                if (body) headers['Content-Type'] = 'application/json';\n                const options = { method, headers, body: body ? JSON.stringify(body) : null };\n                try {\n                    const res = await fetch(GITHUB_API + path, options);\n                    const data = res.status === 204 ? {} : await res.json().catch(() => ({}));\n                    return { ok: res.ok, status: res.status, data };\n                } catch (error) {\n                    return { ok: false, status: 0, error: error.message };\n                }\n            }\n            self.onmessage = async (e) => {\n                const { type, pat, pathInfo, suneContentB64, sha, suneName } = e.data;\n                if (!pathInfo) return self.postMessage({ type: 'error', reason: 'pathInfo is missing.' });\n                const { owner, repo, branch, path } = pathInfo;\n                if (!pat) return self.postMessage({ type: 'error', reason: 'GitHub PAT not found.' });\n                \n                const refParam = branch ? \\`?ref=\\${encodeURIComponent(branch)}\\` : '';\n                const contentsPath = \\`/repos/\\${owner}/\\${repo}/contents/\\${path}\\${refParam}\\`;\n                \n                if (type === 'check') {\n                    const contentRes = await apiCall('GET', contentsPath, pat);\n                    if (contentRes.status === 404) return self.postMessage({ type: 'status_report', exists: false });\n                    if (!contentRes.ok) {\n                        self.postMessage({ type: 'log', message: \\`Error (\\${contentRes.status}) fetching file: \\${contentRes.data?.message || contentRes.error}\\` });\n                        return self.postMessage({ type: 'error', reason: 'Content fetch failed' });\n                    }\n                    const commitSha = branch || 'HEAD';\n                    const commitsPath = \\`/repos/\\${owner}/\\${repo}/commits?sha=\\${commitSha}&path=\\${encodeURIComponent(path)}&page=1&per_page=1\\`;\n                    const commitRes = await apiCall('GET', commitsPath, pat);\n                    const commitDate = (commitRes.ok && commitRes.data.length > 0) ? commitRes.data[0].commit.committer.date : null;\n                    return self.postMessage({ type: 'status_report', exists: true, sha: contentRes.data.sha, commitDate });\n                }\n                \n                if (type === 'fetch_content') {\n                     const res = await apiCall('GET', contentsPath, pat);\n                     if (res.ok) return self.postMessage({ type: 'content_fetched', contentB64: res.data.content, newSha: res.data.sha });\n                     return self.postMessage({ type: 'error', reason: 'Fetch failed' });\n                }\n\n                if (type === 'sync') {\n                    const commitMessage = sha ? \\`Sync: Update sune '\\${suneName}'\\` : \\`Sync: Create sune '\\${suneName}'\\`;\n                    const body = { message: commitMessage, content: suneContentB64 };\n                    if (sha) body.sha = sha;\n                    if (branch) body.branch = branch;\n                    self.postMessage({ type: 'log', message: \\`Committing to \\${owner}/\\${repo}...\\`});\n                    const res = await apiCall('PUT', \\`/repos/\\${owner}/\\${repo}/contents/\\${path}\\`, pat, body);\n                    if (res.ok) {\n                        const newSha = res.data.content.sha;\n                        self.postMessage({ type: 'log', message: \\`✅ Sync successful! New SHA: \\${newSha.substring(0,7)}\\` });\n                        return self.postMessage({ type: 'sync_complete', newSha });\n                    }\n                    self.postMessage({ type: 'log', message: \\`ERROR (\\${res.status}): \\${res.data?.message || res.error || 'Sync failed.'}\\` });\n                    return self.postMessage({ type: 'error', reason: res.data?.message || 'Sync failed' });\n                }\n            };\n        `;\n        const blob = new Blob([workerCode], { type: 'application/javascript' });\n        return new Worker(URL.createObjectURL(blob));\n    };\n    \n    const startWorkerTask = (message, timeout = 20000) => {\n        if (!worker) {\n            log('ERROR: Worker is not initialized.');\n            setBusy(false);\n            return;\n        }\n        clearSyncTimeout();\n        worker.postMessage(message);\n        syncTimeout = setTimeout(() => {\n            log('ERROR: Sync operation timed out. Terminating task.');\n            setBusy(false);\n            cleanup();\n            init(); // Re-initialize for the next attempt\n            log('Sync has been reset. Please try again.');\n        }, timeout);\n    };\n\n    const performForceDownload = () => {\n        if (!state.pathInfo) {\n            log('ERROR: Cannot download, sync path not configured.');\n            return;\n        }\n        const pat = window.USER?.PAT;\n        if (!pat) {\n            log('ERROR: GitHub PAT not found in Account Settings.');\n            return;\n        }\n        if (!confirm(\"Are you sure you want to overwrite your local changes with the version from GitHub? This cannot be undone.\")) {\n            return;\n        }\n\n        log('Force download initiated...');\n        setBusy(true);\n        updateMainSyncBadge('Down');\n        startWorkerTask({ type: 'fetch_content', pat, pathInfo: state.pathInfo });\n    };\n\n    const performUpload = () => {\n        if (!state.pathInfo) return;\n        const pat = window.USER?.PAT;\n        if (!pat) {\n            log('ERROR: GitHub PAT not found in Account Settings.');\n            return;\n        }\n\n        setBusy(true);\n        updateMainSyncBadge('Up');\n        if(!hideUI) {\n            syncBtn.disabled = true;\n            syncBtn.innerHTML = `<i data-lucide=\"loader-2\" class=\"w-5 h-5 mr-2 animate-spin\"></i><span>Uploading...</span>`;\n            if (window.lucide) window.lucide.createIcons();\n        }\n        log('Preparing sune data for upload...');\n        \n        try {\n            const suneToSync = JSON.parse(JSON.stringify(window.SUNE.active));\n            const suneJson = JSON.stringify([suneToSync], null, 2);\n            const suneContentB64 = btoa(unescape(encodeURIComponent(suneJson)));\n            startWorkerTask({ type: 'sync', pat, pathInfo: state.pathInfo, suneContentB64, suneName: window.SUNE.active.name, sha: state.remoteSha });\n        } catch (error) {\n            log(`FATAL: Failed to prepare sune data. ${error.message}`);\n            setBusy(false);\n        }\n    };\n    \n    const handleWorkerMessage = (e) => {\n        clearSyncTimeout();\n        const { type } = e.data;\n        if (type === 'log') return log(e.data.message);\n        \n        if (type === 'error') {\n            log(`Worker error: ${e.data.reason || 'Unknown'}`);\n            setBusy(false);\n            updateSyncButtonUI('upload', state.remoteSha);\n            return;\n        }\n\n        if (type === 'status_report') {\n            const { exists, sha, commitDate } = e.data;\n            const forceSync = state.forceSync;\n            state.forceSync = false;\n\n            if (!exists) {\n                log('File not found on GitHub. Ready to create.');\n                setBusy(false);\n                updateSyncButtonUI('upload', null);\n                if (forceSync) {\n                    log('Force sync: creating file on GitHub...');\n                    performUpload();\n                }\n            } else {\n                const localUpdate = window.SUNE.active.updatedAt;\n                const remoteUpdate = commitDate ? new Date(commitDate).getTime() : 0;\n                \n                if (forceSync) {\n                    log('Force sync: uploading local version...');\n                    setBusy(false);\n                    updateSyncButtonUI('upload', sha);\n                    performUpload();\n                } else if (remoteUpdate > localUpdate + 5000) {\n                    log('Remote is newer. Auto-downloading...');\n                    setBusy(true);\n                    updateMainSyncBadge('Down');\n                    startWorkerTask({ type: 'fetch_content', pat: window.USER.PAT, pathInfo: state.pathInfo });\n                } else if (localUpdate > remoteUpdate + 5000) {\n                    log('Local is newer. Ready to upload.');\n                    setBusy(false);\n                    updateSyncButtonUI('upload', sha);\n                } else {\n                    log('✅ Sune is in sync.');\n                    setBusy(false);\n                    updateSyncButtonUI('synced', sha);\n                }\n            }\n        } else if (type === 'content_fetched') {\n            try {\n                const decodedJson = decodeURIComponent(escape(atob(e.data.contentB64)));\n                const remoteSuneArr = JSON.parse(decodedJson);\n                if (!Array.isArray(remoteSuneArr) || !remoteSuneArr[0]?.id) throw new Error(\"Invalid sune format in remote file.\");\n                \n                const remoteSune = remoteSuneArr[0];\n                const currentSune = window.SUNE.active;\n                \n                Object.assign(currentSune, { ...remoteSune, settings: { ...currentSune.settings, ...remoteSune.settings } });\n                currentSune.updatedAt = Date.now();\n                window.SUNE.save();\n\n                log('✅ Sune updated from GitHub.');\n                updateSyncButtonUI('synced', e.data.newSha);\n\n                if (window.closeSettings) window.closeSettings();\n                if (window.renderSidebar) window.renderSidebar();\n                if (window.reflectActiveSune) window.reflectActiveSune();\n\n            } catch (err) {\n                log(`ERROR processing download: ${err.message}`);\n            } finally {\n                setBusy(false);\n            }\n        } else if (type === 'sync_complete') {\n            window.SUNE.active.updatedAt = Date.now();\n            window.SUNE.save();\n            setBusy(false);\n            updateSyncButtonUI('synced', e.data.newSha);\n        }\n    };\n\n    const startCheck = (isManual = false) => {\n        const pathInfo = parseGhPath(window.SUNE.active.url);\n        if (!pathInfo) return;\n        state.pathInfo = pathInfo;\n\n        if (!window.USER?.PAT) {\n            log('ERROR: GitHub PAT not found in Account Settings.');\n            return;\n        }\n\n        setBusy(true);\n        if (isManual) log('Checking remote status...');\n        startWorkerTask({ type: 'check', pat: window.USER.PAT, pathInfo: state.pathInfo });\n    };\n\n    const parseGhPath = (path) => {\n        const match = (path || '').trim().match(/^gh:\\/\\/([^\\/]+)\\/([^@\\/]+)(?:@([^\\/]+))?\\/(.+)$/);\n        return match ? { owner: match[1], repo: match[2], branch: match[3], path: match[4] } : null;\n    };\n\n    const handleMainSyncClick = (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        if (state.isBusy) {\n            log('Sync is already in progress.');\n            return;\n        }\n        if (state.pathInfo) {\n            log('Manual force sync triggered...');\n            if(!hideUI && logArea) logArea.textContent = '';\n            state.forceSync = true;\n            startCheck(true);\n        }\n    };\n    \n    const init = () => {\n        if (hideUI) {\n            suneContainer.style.display = 'none';\n        }\n        worker = createWorker();\n        worker.onmessage = handleWorkerMessage;\n        \n        createSyncPopover();\n        \n        if (mainSyncButton) {\n            mainSyncButton.style.position = 'relative';\n            const badge = document.createElement('span');\n            badge.id = 'suneSyncBadge';\n            badge.className = 'hidden absolute -top-1 -right-1 h-4 min-w-[1rem] px-1 rounded-full bg-indigo-600 text-white text-[10px] font-bold leading-4 flex items-center justify-center';\n            mainSyncButton.appendChild(badge);\n\n            // Long press for mobile / right-click for desktop\n            const handleLongPress = (e) => {\n                e.preventDefault();\n                showSyncPopover(mainSyncButton);\n            };\n            const startLongPress = (e) => {\n                if (state.isBusy) return;\n                clearTimeout(longPressTimer);\n                longPressTimer = setTimeout(() => handleLongPress(e), 500);\n            };\n            const cancelLongPress = () => clearTimeout(longPressTimer);\n            const contextMenuPrevent = (e) => e.preventDefault();\n\n            mainSyncButton.addEventListener('touchstart', startLongPress, { passive: false });\n            mainSyncButton.addEventListener('touchend', cancelLongPress);\n            mainSyncButton.addEventListener('touchmove', cancelLongPress);\n            mainSyncButton.addEventListener('contextmenu', contextMenuPrevent);\n            mainSyncButton.__syncTouchListeners = { start: startLongPress, cancel: cancelLongPress, context: contextMenuPrevent };\n        }\n\n        log(`GitHub Sync v1.5.0 ready for \"${activeSune.name}\".`);\n        \n        const pathInfo = parseGhPath(activeSune.url);\n        if (pathInfo) {\n            if (!hideUI) {\n                const branchText = pathInfo.branch ? `@<span class=\"font-semibold\">${pathInfo.branch}</span>` : '';\n                infoText.innerHTML = `Sync Target: <br><span class=\"font-mono text-xs bg-gray-200 px-1 py-0.5 rounded\">${pathInfo.owner}/${pathInfo.repo}${branchText}/${pathInfo.path}</span>`;\n            }\n            updateSyncButtonUI('none', null);\n            startCheck(false);\n        } else {\n            if (!hideUI) {\n                infoText.innerHTML = 'Set a `gh://owner/repo@branch/path.sune` URL in Sune settings (click ✺) to enable sync.';\n            }\n            updateSyncButtonUI('none', null);\n        }\n\n        if(!hideUI) syncBtn.addEventListener('click', performUpload);\n        \n        if (mainSyncButton) {\n            if(mainSyncButton.__syncClickListener) mainSyncButton.removeEventListener('click', mainSyncButton.__syncClickListener);\n            mainSyncButton.__syncClickListener = handleMainSyncClick;\n            mainSyncButton.addEventListener('click', mainSyncButton.__syncClickListener);\n        }\n        \n        bodyClickListener = (event) => {\n            if (syncPopover && !syncPopover.classList.contains('hidden')) {\n                if (!syncPopover.contains(event.target) && !mainSyncButton.contains(event.target)) {\n                    hideSyncPopover();\n                }\n            }\n        };\n        document.body.addEventListener('click', bodyClickListener, true);\n\n        if (window.lucide) window.lucide.createIcons();\n\n        const observer = new MutationObserver((mutationsList) => {\n            for (const mutation of mutationsList) {\n                if (mutation.removedNodes) {\n                    for (const removedNode of mutation.removedNodes) {\n                        if (removedNode === suneContainer || removedNode.contains(suneContainer)) {\n                            observer.disconnect();\n                            cleanup();\n                            return;\n                        }\n                    }\n                }\n            }\n        });\n        if (suneContainer.parentElement) {\n            observer.observe(suneContainer.parentElement, { childList: true });\n        }\n    };\n\n    init();\n})();\n</script>\n",
      "extension_html": ""
    }
  }
]